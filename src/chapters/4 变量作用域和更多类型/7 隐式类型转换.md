*原文链接：http://www.learncpp.com/cpp-tutorial/44-implicit-type-conversion-coercion/*

你之前也了解到了，一个变量的值其实是通过一系列的bit来存储的，一个变量的数据类型告诉编译器怎么把这一系列的bit翻译成有意义的值。所以，不同的数据类型可能用不同的形式代表着“相同”的值——例如，整数3盒浮点数3.0有着完全不同的二进制表现形式。

那么当我们这样做的时候发生了什么事情：

    float f = 3; // 把整数值赋给浮点数类型

在这样的情况下，编译器不能直接表示整数值3的bit直接存放到浮点数f中。它需要把整数3转换成浮点数，才能赋值给变量f。

这样把一个值从一种数据类型转换成另外一种数据类型的值的过程称为类型转换。类型转换在很多情况下都会出现。

用不同的数据类型赋值或者初始化一个变量：

    double d = 3; // 把整数值3赋值给一个双精度浮点数
    double d2(3); // 用整数值3初始化一个双精度浮点数

把一个值传入参数数据类型不一样的函数当中：

    void doSomething(long l)
    {
    }
     
    doSomething(3); // 把整数3传入函数，这个函数接受长整型参数

函数返回不同数据类型返回值：

    float doSomething()
    {
        return 3.0; // 3.0是一个双精度浮点数，但是函数返回类型是单精度浮点型
    }

用二元操作符操作不同的数据类型：

    double division = 4.0 / 3; // 用浮点数除以整数

所有的这些情况（还有很多其它情况），C++都会使用类型转换把数据从一种类型转换成另外一种类型。

有两种基本的数据类型转换：**隐式类型转换**，编译器自动地把一种基本的数据类型转换成另外一种基本的数据类型；**显式类型转换**，开发者需要使用类型转换运算符来进行类型转换。

我们会在这一节中讨论隐式类型转换，下一节讨论显示类型转换。

### 隐式类型转换

隐形类型转换（也称**自动类型转换**或者**强制转换**），通常在需要一种基本数据类型的时候，应用了另外一种基本数据类型的值，但是开发者没有明确地（通过转换操作符）告诉编译器如何进行这种转换。

所有上面的这些例子都是隐式类型转换。

有两种不同的隐式类型转换：升级（promotions）和转化（conversions）。































